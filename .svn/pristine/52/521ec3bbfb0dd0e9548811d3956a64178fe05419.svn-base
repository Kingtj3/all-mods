using System;
using System.Collections.Generic;
using System.Text;
using Sandbox.Common.ObjectBuilders;
using Sandbox.Definitions;
using Sandbox.Game;
using Sandbox.Game.Entities;
using Sandbox.Game.EntityComponents;
using Sandbox.Game.Localization;
using Sandbox.ModAPI;
using Sandbox.ModAPI.Interfaces.Terminal;
using SpaceEngineers.Game.ModAPI;
using VRage;
using VRage.Game;
using VRage.Game.Components;
using VRage.Game.Entity;
using VRage.Game.ModAPI;
using VRage.ModAPI;
using VRage.ObjectBuilders;
using VRage.Utils;
using VRage.Voxels;
using VRageMath;
using Vsi.Network;
using Vsi.Utils;

namespace Vsi.AutoMiner
{

    [MyEntityComponentDescriptor(typeof(MyObjectBuilder_VirtualMass), false, "AutoMiner")]
    public class AutoMinerGameLogic : MyGameLogicComponent
    {
        public static Guid ModStorageID = new Guid("525d77d3-b095-412b-a79d-192c3bc98b34");

        public int MiningRadius
        {
            get { return m_miningRadius; }
            private set
            {
                m_miningRadius = value;
                UpdateDetectionRange();
                SyncProperties();
            }

        }
        public int MiningDepth
        {
            get { return m_miningDepth; }
            private set
            {
                m_miningDepth = value;
                UpdateDetectionRange();
                SyncProperties();
            }
        }

        public IMyEntity TargetInventoryEntity
        {
            get
            {
                return m_targetInventoryEntity;
            }
            private set
            {
                m_targetInventoryEntity = value;
                SyncProperties();
            }
        }

        public bool ShowMiningArea
        {
            get { return m_showMiningArea; }
            set
            {
                m_showMiningArea = value;

                if (IsWorking && m_showMiningArea)
                    NeedsUpdate |= MyEntityUpdateEnum.EACH_FRAME;
                else
                    NeedsUpdate ^= MyEntityUpdateEnum.EACH_FRAME;
            }
        }

        private const float REQUIRED_POWER_PER_QUERY_DISTANCE = 0.05f;
        private const float MAX_POWER_CONSUMPTION_MODIFIER = 100f;

        private static List<string> m_availableOres = new List<string>();
        private static Color[] m_blinkColors = { Color.Black, Color.Black, Color.Black, Color.Yellow, Color.Yellow, Color.Yellow };
        private static readonly string[] scanIndicator = { ".", "..", "...", "....", "....." };
        private static List<IMyTerminalControl> m_customControls = new List<IMyTerminalControl>();

        private IMyTerminalControlCombobox m_pushToInventory;

        private AutoMinerDrill m_drill;
        private IMyFunctionalBlock m_block;
        private List<Vector3I> m_conveyorConnections = new List<Vector3I>();

        private float m_operationalPowerConsumption;
        private float m_standByPowerConsumption;

        private IMyInventory m_inventory;
        private MyVoxelBase m_voxelMap;
        private int m_selectedOre;
        private int m_miningRadius;
        private int m_miningDepth;
        private bool m_showMiningArea = true;
        private IMyEntity m_targetInventoryEntity;
        private string m_lastRetrievedOre;
        private int m_blinkCounter;

        private bool m_isNonFixedGrid = false;
        private bool m_isAboveSurfaceOnPlanet = true;
        private bool m_isVertical = true;

        private bool IsPowered
        {
            get { return m_block.ResourceSink.IsPowerAvailable(MyResourceDistributorComponent.ElectricityId, RequiredOperationalPower); }
        }

        private bool IsWorking
        {
            get { return m_block.Enabled && m_block.IsFunctional && m_isVertical; }
        }

        private float RequiredOperationalPower { get { return m_operationalPowerConsumption * (float)m_drill.PowerConsumptionModifier; } }

        public override void Close()
        {
            m_block.CubeGrid.OnBlockRemoved -= OnBlockRemoved;
            m_block.AppendingCustomInfo -= OnAppendingCustomInfo;
            m_block.IsWorkingChanged -= OnWorkingChanged;
            m_block.CubeGrid.OnIsStaticChanged -= OnGridStaticChanged;

            if (Net.IsServer)
                Stop();

            if (Net.IsMultiplayer && Net.IsServer)
            {
                Net.UnregisterEntityMessageHandler(StartMessage.ID, m_block.EntityId);
                Net.UnregisterEntityMessageHandler(StopMessage.ID, m_block.EntityId);
            }

            if (Net.IsMultiplayer && Net.IsClient)
                Net.UnregisterEntityMessageHandler(DrillStateChangedMessage.ID, m_block.EntityId);

            Net.UnregisterEntityMessageHandler(PropertiesChangedMessage.ID, m_block.EntityId);
        }

        public override void Init(MyObjectBuilder_EntityBase objectBuilder)
        {
            m_block = Entity as IMyFunctionalBlock;
            var definition = ((MyCubeBlock)Entity).BlockDefinition as MyVirtualMassDefinition;
            m_operationalPowerConsumption = definition.RequiredPowerInput;
            m_standByPowerConsumption = 0.001f;

            m_drill = new AutoMinerDrill();
            m_drill.OnOreHarvested += OnHarvestMaterial;

            m_block.AppendingCustomInfo += OnAppendingCustomInfo;

            CreateInventory();
            InitAvailableOres();

            lock (m_customControls)
            {
                if (m_customControls.Count == 0)
                    CreateTerminalControls();
            }

            CreateDropbox();

            m_block.CubeGrid.OnBlockRemoved += OnBlockRemoved;

            NeedsUpdate |= MyEntityUpdateEnum.BEFORE_NEXT_FRAME;
            NeedsUpdate |= MyEntityUpdateEnum.EACH_10TH_FRAME;

            if (!m_block.CubeGrid.IsStatic)
                m_isNonFixedGrid = true;
            else
                m_block.CubeGrid.OnIsStaticChanged += OnGridStaticChanged;

            m_block.IsWorkingChanged += OnWorkingChanged;
        }

        public void LoadState()
        {
            AutoMinerState state = null;

            var entity = m_block as IMyEntity;
            var storage = entity.Storage;

            string data;
            if (storage != null && storage.TryGetValue(ModStorageID, out data))
            {
                try
                {
                    state = MyAPIGateway.Utilities.SerializeFromXML<AutoMinerState>(data);
                }
                catch (Exception ex)
                {
                    Log.Error("Unable to load Autominer state: " + ex);
                }
            }

            if (state == null)
                state = new AutoMinerState();

            m_showMiningArea = state.ShowMiningArea;
            m_miningRadius = state.MiningRadius;
            m_miningDepth = state.MiningDepth;
            m_selectedOre = Math.Max(m_availableOres.IndexOf(state.SelectedOre), 0);

            if (Net.IsClient && IsWorking && m_showMiningArea)
                NeedsUpdate |= MyEntityUpdateEnum.EACH_FRAME;

            if (state.TargetInventoryEntity != 0L)
            {
                var ent = MyEntities.GetEntityById(state.TargetInventoryEntity);
                if (ent != null && ((IMyCubeBlock)ent).CubeGrid == m_block.CubeGrid)
                {
                    m_targetInventoryEntity = ent;

                    if (Net.IsServer)
                        NeedsUpdate |= MyEntityUpdateEnum.EACH_100TH_FRAME;
                }
            }

            // This sets the drill area, so needs to be called before setting the current values
            // for the drill's state
            UpdateDetectionRange();

            m_drill.State = state.DrillState;
            m_drill.OreFilter = m_availableOres[m_selectedOre];

            if (Net.IsClient)
                UpdateVisuals();

            m_block.RefreshCustomInfo();
        }

        public void SaveState()
        {
            if (!Net.IsServer)
                return;

            var state = new AutoMinerState()
            {
                Version = 1,
                MiningRadius = MiningRadius,
                MiningDepth = MiningDepth,
                DrillState = m_drill.State,
                ShowMiningArea = ShowMiningArea,
                TargetInventoryEntity = TargetInventoryEntity?.EntityId ?? 0L,
                SelectedOre = m_availableOres[m_selectedOre]
            };

            if (Entity.Storage == null)
                Entity.Storage = new MyModStorageComponent();

            Entity.Storage[ModStorageID] = MyAPIGateway.Utilities.SerializeToXML(state);
        }

        public void Start()
        {
            if (m_drill.IsRunning)
                return;

            Log.Debug($"Started mining ore within {MiningRadius}m radius and {MiningDepth}m depth");

            m_lastRetrievedOre = null;
            m_drill.Start();
            SaveState();

            if (Net.IsServer)
                Net.SendMessageToOthers(new DrillStateChangedMessage(m_block.EntityId, m_drill.State, null));

            if (Net.IsClient)
            {
                UpdateVisuals();
                UpdateDetailInfo();
            }
        }

        public void Stop()
        {
            m_lastRetrievedOre = null;
            m_drill.Stop();
            SaveState();

            if (Net.IsServer)
                Net.SendMessageToOthers(new DrillStateChangedMessage(m_block.EntityId, m_drill.State, null));

            if (Net.IsClient)
            {
                UpdateVisuals();
                UpdateDetailInfo();
            }
        }

        public void Pause()
        {
            m_drill.Pause();
            SaveState();

            if (Net.IsServer)
                Net.SendMessageToOthers(new DrillStateChangedMessage(m_block.EntityId, m_drill.State, m_drill.CurrentOre));

            if (Net.IsClient)
                UpdateDetailInfo();
        }



        public override void UpdateOnceBeforeFrame()
        {
            InitVoxelMap();
            CalculateAngle();

            m_inventory = MyEntityExtensions.GetInventory((MyEntity)m_block, 0);

            m_block.ResourceSink.SetMaxRequiredInputByType(MyResourceDistributorComponent.ElectricityId, m_operationalPowerConsumption * MAX_POWER_CONSUMPTION_MODIFIER);
            m_block.ResourceSink.SetRequiredInputFuncByType(MyResourceDistributorComponent.ElectricityId, () =>
            {
                return (m_block.IsFunctional && m_drill.IsRunning) ? RequiredOperationalPower : m_standByPowerConsumption;
            });

            EnumerateTargetInventoryBlocks();

            m_drill.Init(m_block.WorldMatrix, m_voxelMap);
            LoadState();

            if (Net.IsMultiplayer && Net.IsServer)
            {
                Net.RegisterEntityMessageHandler<StartMessage>(StartMessage.ID, m_block.EntityId, OnMessage_Start);
                Net.RegisterEntityMessageHandler<StopMessage>(StopMessage.ID, m_block.EntityId, OnMessage_Stop);
            }

            if (Net.IsMultiplayer && Net.IsClient)
                Net.RegisterEntityMessageHandler<DrillStateChangedMessage>(DrillStateChangedMessage.ID, m_block.EntityId, OnMessage_DrillStateChanged);

            Net.RegisterEntityMessageHandler<PropertiesChangedMessage>(PropertiesChangedMessage.ID, m_block.EntityId, OnMessage_PropertiesChanged);
        }

        public override void UpdateBeforeSimulation()
        {
            if (Net.IsClient && m_showMiningArea)
                m_drill.DrawDrillArea();
        }

        public override void UpdateBeforeSimulation10()
        {
            if (Net.IsServer && IsWorking)
            {
                var block = ((MyCubeBlock)m_block);
                if (IsPowered)
                {
                    if (m_drill.IsPaused && !m_inventory.IsFull)
                        m_drill.Resume();

                    if (m_drill.IsRunning)
                    {
                        m_drill.Update();
                        block.ResourceSink.Update();
                        SaveState();
                        Net.SendMessageToOthers(new DrillStateChangedMessage(m_block.EntityId, m_drill.State, m_drill.CurrentOre));
                    }
                }
                else if (m_drill.IsRunning)
                {
                    Pause();
                }
            }

            if (Net.IsClient)
            {
                UpdateVisuals();
                UpdateDetailInfo();
            }
        }

        public override void UpdateBeforeSimulation100()
        {
            if (!Net.IsServer)
                return;

            if (TargetInventoryEntity == null)
            {
                NeedsUpdate ^= MyEntityUpdateEnum.EACH_100TH_FRAME;
                return;
            }
            var targetInventory = TargetInventoryEntity.GetInventory();

            if (!targetInventory.IsFull)
                MyInventory.TransferAll((MyInventory)m_inventory, (MyInventory)targetInventory);
        }

        public override void UpdatingStopped()
        {
            if (Net.IsServer)
                SaveState();

            base.UpdatingStopped();
        }

        // On Server and Client
        protected void OnMessage_PropertiesChanged(IMessage message)
        {
            var propertiesChangedMessage = (PropertiesChangedMessage)message;

            m_miningRadius = propertiesChangedMessage.Radius;
            m_miningDepth = propertiesChangedMessage.Depth;
            m_showMiningArea = propertiesChangedMessage.ShowArea;

            m_targetInventoryEntity = propertiesChangedMessage.TargetInventoryEntity != 0L ? MyEntities.GetEntityById(propertiesChangedMessage.TargetInventoryEntity) : null;

            if (Net.IsServer && m_targetInventoryEntity != null)
                NeedsUpdate |= MyEntityUpdateEnum.EACH_100TH_FRAME;

            UpdateDetectionRange();

            if (Net.IsServer)
                SaveState();
        }

        // On Server
        protected void OnMessage_Start(IMessage message)
        {
            Start();
        }

        // On Server
        protected void OnMessage_Stop(IMessage message)
        {
            Stop();
        }

        // On Client
        protected void OnMessage_DrillStateChanged(IMessage message)
        {
            var drillStateMessage = (DrillStateChangedMessage)message;
            m_drill.State = drillStateMessage.DrillState;
            m_lastRetrievedOre = drillStateMessage.LastRetrievedOre;

            UpdateDetailInfo();
        }

        private void CalculateAngle()
        {
            if (m_voxelMap == null || (!(m_voxelMap is MyPlanet)))
                return;

            var planet = m_voxelMap as MyPlanet;

            // Find the angle of the block

            var cubeBlock = Entity as MyCubeBlock;
            var position = Entity.GetPosition();
            var blockDown = cubeBlock.WorldMatrix.Down;
            var surfacePosition = planet.GetClosestSurfacePointGlobal(ref position);
            var gravityAtPosition = Vector3D.Normalize(planet.PositionComp.GetPosition() - surfacePosition);

            var dot = Vector3D.Dot(gravityAtPosition, blockDown);
            var ll = gravityAtPosition.Length() * blockDown.Length();

            // angle here will be 0 - PI, so first convert it to a range of -PI/2 to PI/2, then
            // scale it to -3 - 3 on both sides. 
            var angleRad = Math.Abs(Math.Acos(dot / ll) - (Math.PI / 2.0));
            var angle = MathHelper.ToDegrees(angleRad);

            Log.Info($"ANGLE: {angle}");

            if (angle < 45)
                m_isVertical = false;
        }

        private void CreateInventory()
        {
            var description = string.Format(MyTexts.GetString(MySpaceTexts.ToolTipItemFilter_GenericProductionBlockInput), m_block.DisplayNameText);
            var inventory = new MyInventory(4, new Vector3I(2), MyInventoryFlags.CanReceive | MyInventoryFlags.CanSend);
            var inventoryConstraint = new MyInventoryConstraint(description);

            inventoryConstraint.AddObjectBuilderType(typeof(MyObjectBuilder_Ore));

            inventory.Constraint = inventoryConstraint;
            Entity.Components.Add((MyInventoryBase)inventory);
        }

        private void EnumerateTargetInventoryBlocks()
        {
            var localGridPosition = m_block.Position + (Vector3I)m_block.LocalMatrix.Down;
            m_conveyorConnections.Add(localGridPosition);
        }

        private void InitVoxelMap()
        {
            if (m_voxelMap == null)
            {
                var detectionRange = new BoundingSphereD(m_block.GetPosition(), 10);
                var entities = MyAPIGateway.Entities.GetEntitiesInSphere(ref detectionRange);

                foreach (var entity in entities)
                {
                    if (entity is MyVoxelBase)
                    {
                        m_voxelMap = entity as MyVoxelBase;
                        if (entity is MyPlanet)
                            break;
                    }
                }
            }

            if (m_voxelMap != null && m_voxelMap is MyPlanet)
            {
                var planet = m_voxelMap as MyPlanet;
                var surfacePoint = planet.GetClosestSurfacePointGlobal(m_block.GetPosition());
                var center = planet.PositionComp.GetPosition();

                var blockDist = (m_block.GetPosition() - center).Length();
                var surfaceDist = (surfacePoint - center).Length();

                if (blockDist < surfaceDist)
                    m_isAboveSurfaceOnPlanet = false;
            }
        }

        private void OnAppendingCustomInfo(IMyTerminalBlock block, StringBuilder sb)
        {
            sb.AppendLine();
            sb.Append("Status: ");

            if (!m_block.IsWorking)
                sb.AppendLine("Offline");
            else if (m_drill.IsRunning)
                sb.AppendLine("Mining");
            else if (m_drill.IsPaused)
            {
                sb.AppendLine("Paused");

                if (IsPowered)
                    sb.AppendLine("\nInventory is full!");
                else
                {
                    sb.AppendLine("\nNot enough power!");
                    sb.Append("Required operating power: ");
                    MyValueFormatter.AppendWorkInBestUnit(RequiredOperationalPower, sb);
                    sb.AppendLine();
                }
            }
            else
                sb.AppendLine("Idle");

            if (m_drill.IsRunning)
            {
                sb.AppendLine($"Current Depth: {m_drill.CurrentDepth} m");
                // sb.AppendLine($"Power modifier: {m_drill.PowerConsumptionModifier}");

                if (m_drill.CurrentOre != null)
                    m_lastRetrievedOre = m_drill.CurrentOre;

                sb.AppendLine($"Processing ore: {m_lastRetrievedOre}");
            }

            if (m_isNonFixedGrid)
                sb.AppendLine("\nWorks only on fixed grids!");

            if (!m_isAboveSurfaceOnPlanet)
                sb.AppendLine("\nMust be placed above the surface");

            if (!m_isVertical)
                sb.AppendLine("\nMust be vertical (within 45°)!");
        }

        private void OnBlockRemoved(IMySlimBlock block)
        {
            var fatBlock = block.FatBlock;
            if (fatBlock == null)
                return;

            if (TargetInventoryEntity != null && TargetInventoryEntity.EntityId == fatBlock.EntityId)
                TargetInventoryEntity = null;
        }

        private void OnGridStaticChanged(IMyCubeGrid cubeGrid, bool newValue)
        {
            if (!newValue)
            {
                m_isNonFixedGrid = true;
                Stop();
            }
        }

        private void OnHarvestMaterial(byte material, float amount)
        {
            var voxelMat = MyDefinitionManager.Static.GetVoxelMaterialDefinition(material);
            // Log.Info($"HARVEST_CLIENT: {voxelMat.MinedOre}, Mat: {material}, Amount: {amount}");
            var oreObjBuilder = MyObjectBuilderSerializer.CreateNewObject<MyObjectBuilder_Ore>(voxelMat.MinedOre);
            oreObjBuilder.MaterialTypeName = voxelMat.Id.SubtypeId;

            float amountCubicMeters = (float)((amount / (float)MyVoxelConstants.VOXEL_CONTENT_FULL) * MyVoxelConstants.VOXEL_VOLUME_IN_METERS * MyDrillConstants.VOXEL_HARVEST_RATIO);
            amountCubicMeters *= (float)voxelMat.MinedOreRatio;

            var physItem = MyDefinitionManager.Static.GetPhysicalItemDefinition(oreObjBuilder);
            MyFixedPoint amountInItemCount = (MyFixedPoint)(amountCubicMeters / physItem.Volume);

            var myObjectBuilder_PhysicalObject = oreObjBuilder as MyObjectBuilder_PhysicalObject;
            var id = myObjectBuilder_PhysicalObject.GetObjectId();
            var maxAmount = ((MyInventory)m_inventory).ComputeAmountThatFits(id, 0f, 0f);

            ((MyInventory)m_inventory).AddItems(MyFixedPoint.Min(amountInItemCount, maxAmount), oreObjBuilder);
            m_lastRetrievedOre = null;

            if (m_inventory.IsFull)
                Pause();
        }

        private void OnWorkingChanged(IMyCubeBlock block)
        {
            ShowMiningArea = m_showMiningArea;
        }

        private void CreateDropbox()
        {
            var dropdown = MyAPIGateway.TerminalControls.CreateControl<IMyTerminalControlCombobox, IMyArtificialMassBlock>("TargetInventory");

            dropdown.Title = MyStringId.GetOrCompute("Push to target inventory");
            dropdown.ComboBoxContent = (list) =>
            {
                foreach (var gridPos in m_conveyorConnections)
                {
                    var slimBlock = m_block.CubeGrid.GetCubeBlock(gridPos);
                    var fatBlock = slimBlock?.FatBlock;

                    if (fatBlock != null && fatBlock.EntityId != m_block.EntityId && fatBlock.GetInventory() != null)
                    {
                        list.Add(new MyTerminalControlComboBoxItem
                        {
                            Key = fatBlock.EntityId,
                            Value = MyStringId.GetOrCompute(((IMyTerminalBlock)fatBlock).CustomName)
                        });
                    }
                }
            };

            dropdown.Getter = (block) =>
            {
                if (block == null || block.GameLogic == null)
                    return 0;

                var logic = block.GameLogic.GetAs<AutoMinerGameLogic>();
                return logic != null && logic.TargetInventoryEntity != null ? logic.TargetInventoryEntity.EntityId : 0L;
            };

            dropdown.Setter = (block, value) =>
            {
                var logic = block.GameLogic.GetAs<AutoMinerGameLogic>();

                if (logic != null)
                {
                    logic.TargetInventoryEntity = MyEntities.GetEntityById(value);
                    logic.NeedsUpdate |= MyEntityUpdateEnum.EACH_100TH_FRAME;
                }
            };

            m_pushToInventory = dropdown;
        }

        private void CreateTerminalControls()
        {
            MyAPIGateway.TerminalControls.CustomControlGetter -= CustomControlGetter;
            MyAPIGateway.TerminalControls.CustomControlGetter += CustomControlGetter;

            Func<IMyTerminalBlock, bool> enabledFunc = (block) =>
            {
                var logic = block.GameLogic.GetAs<AutoMinerGameLogic>();
                return (logic != null && block.IsFunctional) ? !logic.m_drill.IsRunning : false;
            };

            var dropdown = MyAPIGateway.TerminalControls.CreateControl<IMyTerminalControlCombobox, IMyArtificialMassBlock>("AutominerTargetOre");
            #region Ore
            dropdown.Title = MyStringId.GetOrCompute("Ore");
            dropdown.Getter = (block) =>
            {
                if (block == null || block.GameLogic == null)
                    return 0;

                var logic = block.GameLogic.GetAs<AutoMinerGameLogic>();
                return logic != null ? logic.m_selectedOre : 0;
            };

            dropdown.Setter = (block, value) =>
            {
                var logic = block.GameLogic.GetAs<AutoMinerGameLogic>();

                if (logic != null)
                {
                    logic.m_selectedOre = (int)value;
                    logic.m_drill.OreFilter = m_availableOres[(int)value];
                    logic.SaveState();
                }
            };

            dropdown.ComboBoxContent = (elements) =>
            {
                elements.Clear();
                foreach (var ore in m_availableOres)
                    elements.Add(new MyTerminalControlComboBoxItem { Key = elements.Count, Value = MyStringId.GetOrCompute(ore) });
            };

            dropdown.Enabled = enabledFunc;

            m_customControls.Add(dropdown);
            #endregion

            var slider = MyAPIGateway.TerminalControls.CreateControl<IMyTerminalControlSlider, IMyArtificialMassBlock>("MiningRadius");

            slider.Title = MyStringId.GetOrCompute("Radius");
            slider.SetLimits(0, 5000);
            slider.Getter = (block) =>
            {
                if (block == null || block.GameLogic == null)
                    return 0;

                var logic = block.GameLogic.GetAs<AutoMinerGameLogic>();
                return logic != null ? logic.MiningRadius : 0;
            };

            slider.Setter = (block, value) =>
            {
                var logic = block.GameLogic.GetAs<AutoMinerGameLogic>();

                if (logic != null)
                    logic.MiningRadius = (int)value;
            };

            slider.Writer = (block, sb) =>
            {
                var logic = block.GameLogic.GetAs<AutoMinerGameLogic>();

                if (logic != null)
                    MyValueFormatter.AppendDistanceInBestUnit(logic.MiningRadius, sb);
            };

            slider.Enabled = enabledFunc;

            m_customControls.Add(slider);

            slider = MyAPIGateway.TerminalControls.CreateControl<IMyTerminalControlSlider, IMyArtificialMassBlock>("MiningDepth");

            slider.Title = MyStringId.GetOrCompute("Depth");
            slider.SetLimits(block => 0f, block => {
                if (block == null || block.GameLogic == null)
                    return 0f;

                var logic = block.GameLogic.GetAs<AutoMinerGameLogic>();
                if (logic == null)
                    return 0f;

                return logic.m_voxelMap is MyPlanet ? 100000f : 150f;
            });

            slider.Getter = (block) =>
            {
                if (block == null || block.GameLogic == null)
                    return 0;

                var logic = block.GameLogic.GetAs<AutoMinerGameLogic>();
                return logic != null ? logic.MiningDepth : 0;
            };

            slider.Setter = (block, value) =>
            {
                var logic = block.GameLogic.GetAs<AutoMinerGameLogic>();

                if (logic != null)
                    logic.MiningDepth = (int)value;
            };

            slider.Writer = (block, sb) =>
            {
                var logic = block.GameLogic.GetAs<AutoMinerGameLogic>();

                if (logic != null)
                    MyValueFormatter.AppendDistanceInBestUnit(logic.MiningDepth, sb);
            };

            slider.Enabled = enabledFunc;

            m_customControls.Add(slider);

            var button = MyAPIGateway.TerminalControls.CreateControl<IMyTerminalControlButton, IMyArtificialMassBlock>("StartMining");

            button.Title = MyStringId.GetOrCompute("Start");
            button.Action = (block) =>
            {
                var logic = block.GameLogic.GetAs<AutoMinerGameLogic>();

                if (logic != null)
                {
                    if (!Net.IsServer)
                        Net.SendMessageToServer(new StartMessage(logic.Entity.EntityId));
                    else
                        logic.Start();
                }
            };

            button.Enabled = (block) =>
            {
                var logic = block.GameLogic.GetAs<AutoMinerGameLogic>();
                return (logic != null && logic.IsWorking) ? !logic.m_isNonFixedGrid && logic.m_isAboveSurfaceOnPlanet && !logic.m_drill.IsRunning : false;
            };

            m_customControls.Add(button);

            button = MyAPIGateway.TerminalControls.CreateControl<IMyTerminalControlButton, IMyArtificialMassBlock>("StopMining");

            button.Title = MyStringId.GetOrCompute("Stop");
            button.Action = (block) =>
            {
                var logic = block.GameLogic.GetAs<AutoMinerGameLogic>();

                if (logic != null)
                {
                    if (!Net.IsServer)
                        Net.SendMessageToServer(new StopMessage(logic.Entity.EntityId));
                    else
                        logic.Stop();
                }
            };

            button.Enabled = (block) =>
            {
                var logic = block.GameLogic.GetAs<AutoMinerGameLogic>();
                return (logic != null && logic.IsWorking) ? logic.m_drill.IsRunning : false;
            };

            m_customControls.Add(button);

            var checkbox = MyAPIGateway.TerminalControls.CreateControl<IMyTerminalControlCheckbox, IMyArtificialMassBlock>("ShowMiningArea");

            checkbox.Title = MyStringId.GetOrCompute("Show Mining Area");
            checkbox.Getter = (block) =>
            {
                if (block == null || block.GameLogic == null)
                    return false;

                var logic = block.GameLogic.GetAs<AutoMinerGameLogic>();
                return logic?.ShowMiningArea ?? false;
            };

            checkbox.Setter = (block, value) =>
            {
                var logic = block.GameLogic.GetAs<AutoMinerGameLogic>();
                if (logic != null)
                    logic.ShowMiningArea = value;
            };

            m_customControls.Add(checkbox);
        }

        private void InitAvailableOres()
        {
            if (m_availableOres.Count == 0)
            {
                lock (m_availableOres)
                {
                    foreach (var definition in MyDefinitionManager.Static.GetVoxelMaterialDefinitions())
                    {
                        if (!definition.IsRare)
                            continue;

                        if (!m_availableOres.Contains(definition.MinedOre))
                            m_availableOres.Add(definition.MinedOre);
                    }

                    m_availableOres.Sort();
                    m_availableOres.Insert(0, "Any");
                }
            }
        }

        private void SyncProperties()
        {
            Net.SendMessageToOthers(new PropertiesChangedMessage(this));
        }

        private void UpdateDetailInfo()
        {
            m_block.RefreshCustomInfo();

            // Hack to trigger the refresh of detailed info, but make sure
            // we don't react to the resulting IsWorkingChanged events

            m_block.IsWorkingChanged -= OnWorkingChanged;
            m_block.Enabled = !m_block.Enabled;
            m_block.Enabled = !m_block.Enabled;
            m_block.IsWorkingChanged += OnWorkingChanged;
        }

        private void UpdateDetectionRange()
        {
            m_drill.DrillArea = new BoundingBoxD(
                new Vector3D(-MiningRadius, -MiningRadius, AutoMinerDrill.DRILL_OFFSET),
                new Vector3D(MiningRadius, MiningRadius, MiningDepth + AutoMinerDrill.DRILL_OFFSET));

            UpdateDetailInfo();
        }

        private void UpdateVisuals()
        {
            var color = Color.Red;

            if (IsWorking)
            {
                if (m_drill.IsPaused)
                {
                    color = m_blinkColors[m_blinkCounter];
                    m_blinkCounter = ++m_blinkCounter % 6;
                }
                else
                {
                    color = m_drill.IsRunning ? Color.Green : Color.Yellow;
                }
            }

            m_block.SetEmissiveParts($"Emissive0", color, 1f);
        }

        private static void CustomControlGetter(IMyTerminalBlock block, List<IMyTerminalControl> controls)
        {
            if (block == null || block.GameLogic == null)
                return;

            var logic = block.GameLogic.GetAs<AutoMinerGameLogic>();

            if (logic != null)
            {
                controls.Add(logic.m_pushToInventory);
                controls.AddRange(m_customControls);
            }
        }
    }
}